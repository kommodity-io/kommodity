#!/usr/bin/env bash

providers_yaml="pkg/provider/providers.yaml"
output_file="pkg/provider/scheme.go"

cat > "$output_file" <<EOF
// Code generated by add-to-scheme-providers.sh; DO NOT EDIT.

package provider //nolint

import (
    "k8s.io/apimachinery/pkg/runtime"
    "k8s.io/apimachinery/pkg/runtime/schema"

EOF

alias_counter=0

count=$(yq '.providers | length' "$providers_yaml")
for i in $(seq 0 $((count - 1))); do
  repo=$(yq ".providers[$i].repository" "$providers_yaml")
  go_module=$(yq -r ".providers[$i].go_module" "$providers_yaml")
  scheme_locations=$(yq -r ".providers[$i].scheme_locations[]" "$providers_yaml")

  if [ "$go_module" != "null" ] && [ -n "$go_module" ]; then
    base="$go_module"
  else
    base="github.com/$repo"
  fi

  for scheme_location in $scheme_locations; do
    alias="scheme_$((alias_counter+=1))"
    echo -e "\t$alias \"$base/$scheme_location\"" >> "$output_file"
  done
done

cat >> "$output_file" <<EOF
)

func addAllProvidersToScheme(scheme *runtime.Scheme) error {
    var err error
EOF


# Generate AddToScheme calls for each import alias
yq -r '.providers[].scheme_locations[]' "$providers_yaml" | \
  awk '{ alias="scheme_" NR; printf "\tif err = %s.AddToScheme(scheme); err != nil { return err }\n", alias }' >> "$output_file"

cat >> "$output_file" <<EOF
    return nil
}
EOF

cat >> "$output_file" <<EOF

func GetProviderGroupKindVersions() []schema.GroupVersion {
  return []schema.GroupVersion{
EOF


yq -r '.providers[] | (.go_module // .repository) as $base | .scheme_locations[] | $base + "/" + .' "$providers_yaml" | \
  awk '{ alias="scheme_" NR; printf "\t\t%s.GroupVersion,\n", alias }' >> "$output_file"

cat >> "$output_file" <<EOF
  }
}
EOF